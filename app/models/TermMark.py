from app import db
from datetime import datetime
from . import Utils
from sqlalchemy.ext.associationproxy import association_proxy


class TermMark(db.Model):
    # Don't touch this, it's managed
    _id = db.Column(db.Integer, primary_key=True, name='id')
    _term_ID = db.Column(db.Integer, db.ForeignKey("terms.id", ondelete='CASCADE'), nullable=False)
    _student_ID = db.Column(db.Integer, db.ForeignKey("users.id", ondelete='CASCADE'), nullable=False)
    _modified_by_ID = db.Column(db.Integer, db.ForeignKey("users.id", ondelete='SET NULL'), nullable=True)
    # Attributes
    uuid = db.Column(db.String(40), nullable=False, default=Utils.str_uuid4)
    mark = db.Column(db.Integer, nullable=False, default=0)
    lastModified = db.Column(db.DateTime, nullable=True)
    # Relationship abstractions
    student = db.relationship("User", backref=db.backref("term_marks", cascade='all,delete'),
                              foreign_keys=[_student_ID])
    lastModifiedBy = db.relationship("User", foreign_keys=[_modified_by_ID])
    term = db.relationship("Term", backref=db.backref("marks", cascade='all,delete'))
    # Proxies
    course = association_proxy("term", "course")

    @db.validates("uuid")
    def uuid_edit_block(self, key, value):
        if self.uuid:  # Already exists
            raise ValueError("UUID is autogenerated and can not be modified!")
        return value

    def __init__(self, student, term, *args, **kwargs):
        self.student = student
        self.term = term
        super(TermMark, self).__init__(*args, **kwargs)

    def modify(self, mark, by_user):
        self.mark = mark
        self.lastModifiedBy = by_user
        self.lastModified = datetime.utcnow()

    def get_last_modified(self):
        return (self.lastModifiedBy or ""), (self.lastModified or "")

    def __repr__(self):
        return f"TermMark[{self._id}] last modified {self._lastModified}"
